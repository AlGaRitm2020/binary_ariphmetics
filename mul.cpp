#include <iostream>
#include <bitset>
#include <cmath>
#include <string>

using namespace std;

int main(){
    int a, b;
    int sign;
    cout << "A(decimal): "; cin >> a;
    cout << "B(decimal): "; cin >> b;
    int a_abs = a; 
    int b_abs = b;

    // получаем знаковые биты чисел
    unsigned int s1 = *((unsigned int *)&a) >> 31; // s1 и s2 - знаки. 0 значит положительное число, 1 значит отрицательное
    unsigned int s2 = *((unsigned int *)&b) >> 31; // префикс unsigned имеет значение, т.к. если представлять код "1" в знаковом виде, то при переводе в число получим -1 
    printf("sign_a: %d\tsign_b: %d \n", s1,s2);

    // вычисляем знаковый бит произведения
    sign = (s1 + s2) % 2;
    printf("Mul sign: %d\n", sign);


    // ищем абсолютные значения чисел; используем алгоритм дополнительного кода; ХОR числа со всеми единицами ни что иное, как инверсия всех битов
    // в данном случае переводим число из отрицательного в положительное; если же изначально положительное, то ничего не делаем
    if (s1) {
        a_abs = a - 1;
        a_abs = a_abs ^  0xFFFFFFFF; // инверсия
    }
    if (s2) {
        b_abs = b - 1;
        b_abs = b_abs ^  0xFFFFFFFF; // инверсия
    }

    printf("Absolute values: %d and %d\n", a, b);



    int c = 0;
    // вычисляем модуль произведения. Берем биты из b начиная с последнего и умножаем на а, делая сдвиг после каждого шага
    // выполняем СДВИГ ВЛЕВО числа А, а не сдвиг вправо C. посмотрите что такое сдвиг вправо в википедии и поймёте, что это нам не подходит
    // по факту алгоритм точно такой же как и умножение в столбик из начальной школы. Там мы тоже поразрядно умножали, свдигая с каждым разрядом первый множитель влево

    while (b_abs !=0 ) {
        int bi = b_abs % 2;

        if (bi == 0)
            a_abs = a_abs << 1;
        else {
            c = c + a_abs;
            a_abs = a_abs << 1;   
        }
        b_abs /= 2;

    }
    
    // инвертируем число если знак должен быть равен 1; используем алгоритм дополнительного кода; ХОR числа со всеми единицами ни что иное, как инверсия всех битов
    if (sign){
        c = c ^ 0xFFFFFFFF; // инверсия
        c = c + 1;
        printf("Result: %d * %d = %d\n", a, b, c);


    }
    else {
          printf("Result: %d * %d = %d\n", a, b, c);

    }


    return 0;

}


/*
a = 10
b = 1111
cm1 = 1111
a1 = 100
cm2 = 1111 + 100 = 


*/